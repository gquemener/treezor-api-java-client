/*
 * Treezor API
 * Official endpoint documentation for Treezor.
 *
 * The version of the OpenAPI document: 24.11.21
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-26T10:05:33.742486471+01:00[Europe/Paris]", comments = "Generator version: 7.10.0")
public class BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner {
  public static final String SERIALIZED_NAME_UNIQUE_MANDATE_REFERENCE = "uniqueMandateReference";
  @SerializedName(SERIALIZED_NAME_UNIQUE_MANDATE_REFERENCE)
  @javax.annotation.Nonnull
  private String uniqueMandateReference;

  public static final String SERIALIZED_NAME_IS_RECURRENT = "isRecurrent";
  @SerializedName(SERIALIZED_NAME_IS_RECURRENT)
  @javax.annotation.Nonnull
  private Boolean isRecurrent;

  public static final String SERIALIZED_NAME_WALLET_ID = "walletId";
  @SerializedName(SERIALIZED_NAME_WALLET_ID)
  @javax.annotation.Nullable
  private BigDecimal walletId;

  public BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner() {
  }

  public BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner uniqueMandateReference(@javax.annotation.Nonnull String uniqueMandateReference) {
    this.uniqueMandateReference = uniqueMandateReference;
    return this;
  }

  /**
   * Unique Mandate Reference that unambiguiously identify a mandate signed between the user and the beneficiary 
   * @return uniqueMandateReference
   */
  @javax.annotation.Nonnull
  public String getUniqueMandateReference() {
    return uniqueMandateReference;
  }

  public void setUniqueMandateReference(@javax.annotation.Nonnull String uniqueMandateReference) {
    this.uniqueMandateReference = uniqueMandateReference;
  }


  public BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner isRecurrent(@javax.annotation.Nonnull Boolean isRecurrent) {
    this.isRecurrent = isRecurrent;
    return this;
  }

  /**
   * If mandate is a recuring payment, this field must be true. 
   * @return isRecurrent
   */
  @javax.annotation.Nonnull
  public Boolean getIsRecurrent() {
    return isRecurrent;
  }

  public void setIsRecurrent(@javax.annotation.Nonnull Boolean isRecurrent) {
    this.isRecurrent = isRecurrent;
  }


  public BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner walletId(@javax.annotation.Nullable BigDecimal walletId) {
    this.walletId = walletId;
    return this;
  }

  /**
   * If present, the Direct Debit will be accepted only if the targeted wallet is the wallet with the given walletId. Without this value, the SDD can target any wallets of the user. With the value specified, only the explicitely authorized wallet can be targeted by SDD. 
   * @return walletId
   */
  @javax.annotation.Nullable
  public BigDecimal getWalletId() {
    return walletId;
  }

  public void setWalletId(@javax.annotation.Nullable BigDecimal walletId) {
    this.walletId = walletId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner beneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner = (BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner) o;
    return Objects.equals(this.uniqueMandateReference, beneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.uniqueMandateReference) &&
        Objects.equals(this.isRecurrent, beneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.isRecurrent) &&
        Objects.equals(this.walletId, beneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.walletId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uniqueMandateReference, isRecurrent, walletId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner {\n");
    sb.append("    uniqueMandateReference: ").append(toIndentedString(uniqueMandateReference)).append("\n");
    sb.append("    isRecurrent: ").append(toIndentedString(isRecurrent)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("uniqueMandateReference");
    openapiFields.add("isRecurrent");
    openapiFields.add("walletId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("uniqueMandateReference");
    openapiRequiredFields.add("isRecurrent");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner is not found in the empty JSON string", BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("uniqueMandateReference").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uniqueMandateReference` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uniqueMandateReference").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.class));

       return (TypeAdapter<T>) new TypeAdapter<BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner>() {
           @Override
           public void write(JsonWriter out, BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner
   * @throws IOException if the JSON string is invalid with respect to BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner
   */
  public static BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner.class);
  }

  /**
   * Convert an instance of BeneficiaryObjectBeneficiariesInnerSddB2bWhitelistInner to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

